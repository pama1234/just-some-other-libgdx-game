package org.eclipse.tm4e.ui.text;

import static org.eclipse.tm4e.core.internal.utils.NullSafetyHelper.castNonNull;

import java.lang.reflect.Field;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.content.IContentType;
import org.eclipse.core.runtime.preferences.IEclipsePreferences.IPreferenceChangeListener;
import org.eclipse.core.runtime.preferences.IEclipsePreferences.PreferenceChangeEvent;
import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.ITextInputListener;
import org.eclipse.jface.text.ITextListener;
import org.eclipse.jface.text.ITextOperationTarget;
import org.eclipse.jface.text.ITextViewer;
import org.eclipse.jface.text.ITextViewerExtension5;
import org.eclipse.jface.text.Region;
import org.eclipse.jface.text.TextEvent;
import org.eclipse.jface.text.TextPresentation;
import org.eclipse.jface.text.presentation.IPresentationDamager;
import org.eclipse.jface.text.presentation.IPresentationReconciler;
import org.eclipse.jface.text.presentation.IPresentationRepairer;
import org.eclipse.jface.text.source.SourceViewer;
import org.eclipse.swt.custom.StyleRange;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.widgets.Control;
import org.eclipse.tm4e.core.TMException;
import org.eclipse.tm4e.core.grammar.IGrammar;
import org.eclipse.tm4e.core.model.ModelTokensChangedEvent;
import org.eclipse.tm4e.registry.TMEclipseRegistryPlugin;
import org.eclipse.tm4e.ui.TMUIPlugin;
import org.eclipse.tm4e.ui.internal.model.TMModelManager;
import org.eclipse.tm4e.ui.internal.preferences.PreferenceConstants;
import org.eclipse.tm4e.ui.internal.text.TMPresentationReconcilerTestGenerator;
import org.eclipse.tm4e.ui.internal.themes.ThemeManager;
import org.eclipse.tm4e.ui.internal.utils.ContentTypeHelper;
import org.eclipse.tm4e.ui.internal.utils.ContentTypeInfo;
import org.eclipse.tm4e.ui.internal.utils.MarkerUtils;
import org.eclipse.tm4e.ui.internal.utils.PreferenceUtils;
import org.eclipse.tm4e.ui.themes.ITheme;
import org.eclipse.tm4e.ui.themes.IThemeManager;
import org.eclipse.tm4e.ui.themes.ITokenProvider;
import org.eclipse.ui.IEditorPart;

import com.badlogic.gdx.graphics.Color;

import pama1234.shift.misc.NonNullByDefault;

@Deprecated
public class TMPresentationReconciler implements IPresentationReconciler{
  public static @Nullable TMPresentationReconciler getTMPresentationReconciler(final @Nullable IEditorPart editorPart) {
    if(editorPart==null) return null;
    final @Nullable ITextOperationTarget target=editorPart.getAdapter(ITextOperationTarget.class);
    return target instanceof final ITextViewer textViewer
      ?TMPresentationReconciler.getTMPresentationReconciler(textViewer)
      :null;
  }
  public static @Nullable TMPresentationReconciler getTMPresentationReconciler(final ITextViewer textViewer) {
    try {
      final Field presentationReconcilerField=SourceViewer.class.getDeclaredField("fPresentationReconciler");
      if(presentationReconcilerField!=null) {
        presentationReconcilerField.trySetAccessible();
        return presentationReconcilerField.get(textViewer) instanceof final TMPresentationReconciler tmPresentationReconciler
          ?tmPresentationReconciler
          :null;
      }
    }catch(SecurityException|NoSuchFieldException ex) {
      // in case the SourceViewer class no longer has the fPresentationReconciler field or changed access level
      TMUIPlugin.logError(ex);
    }catch(IllegalArgumentException|IllegalAccessException|NullPointerException|ExceptionInInitializerError ex) {
      // This should not be logged as an error. This is an expected possible outcome of field.get(textViewer).
      // The method assumes ITextViewer is actually ISourceViewer, and specifically the SourceViewer implementation
      // that was available at the current build. This code also works with any implementation that follows the
      // internal structure if also an ITextViewer.
      // If these assumptions are false, the method should return null. Logging just causes repeated noise.
    }
    return null;
  }
  private final ModelTokensChangedEvent.Listener modelsTokensChangedListener=new ModelTokensChangedEvent.Listener() {
    @Override
    public void onModelTokensChanged(final ModelTokensChangedEvent event) {
      final var colorizer=TMPresentationReconciler.this.colorizer;
      if(colorizer!=null) {
        final Control control=colorizer.getTextViewer().getTextWidget();
        if(control!=null) {
          control.getDisplay().asyncExec(()->colorizer.colorize(event));
        }
      }
      MarkerUtils.updateTextMarkers(event);
    }
  };
  private final IPreferenceChangeListener themeChangeListener=new IPreferenceChangeListener() {
    @Override
    public void preferenceChange(final @Nullable PreferenceChangeEvent event) {
      if(event==null) return;
      switch(event.getKey()) {
        case PreferenceConstants.E4_THEME_ID:
          preferenceThemeChange((String)event.getNewValue(),TMUIPlugin.getThemeManager());
          break;
        case PreferenceConstants.THEME_ASSOCIATIONS:
          preferenceThemeChange(PreferenceUtils.getE4PreferenceCSSThemeId(),TMUIPlugin.getThemeManager());
          break;
      }
    }
    void preferenceThemeChange(final @Nullable String eclipseThemeId,final IThemeManager themeManager) {
      final IDocument doc=getViewerDocument();
      if(doc==null) return;
      final var grammar=TMPresentationReconciler.this.grammar;
      if(grammar==null) return;
      // Select the well TextMate theme from the given E4 theme id.
      final boolean dark=themeManager.isDarkEclipseTheme(eclipseThemeId);
      final ITheme newTheme=themeManager.getThemeForScope(grammar.getScopeName(),dark);
      setTheme(newTheme);
    }
  };
  private @Nullable ITextViewer viewer;
  private final TextViewerListener viewerListener=new TextViewerListener();
  private volatile @Nullable Colorizer colorizer;
  private @Nullable IGrammar grammar;
  private boolean isForcedGrammar;
  private @Nullable ITokenProvider theme;
  private final Set<ITMPresentationReconcilerListener> listeners=new CopyOnWriteArraySet<>();
  public TMPresentationReconciler() {
    if(PreferenceUtils.isDebugGenerateTest()) {
      addListener(new TMPresentationReconcilerTestGenerator());
    }
  }
  private final class TextViewerListener implements ITextInputListener,ITextListener{
    @Override
    public void inputDocumentAboutToBeChanged(final @Nullable IDocument oldDoc,final @Nullable IDocument newDoc) {
      if(oldDoc==null) return;
      final var viewer=TMPresentationReconciler.this.viewer;
      if(viewer!=null) {
        viewer.removeTextListener(TMPresentationReconciler.this.viewerListener);
      }
      TMModelManager.INSTANCE.disconnect(oldDoc);
      listeners.forEach(l->l.onUninstalled());
    }
    @Override
    public void inputDocumentChanged(final @Nullable IDocument oldDoc,final @Nullable IDocument newDoc) {
      if(newDoc==null) return;
      final var viewer=TMPresentationReconciler.this.viewer;
      if(viewer==null) return;
      listeners.forEach(l->l.onInstalled(viewer,newDoc));
      try {
        viewer.addTextListener(TMPresentationReconciler.this.viewerListener);
        // update the grammar
        IGrammar newDocGrammar;
        if(isForcedGrammar) {
          newDocGrammar=TMPresentationReconciler.this.grammar;
        }else {
          newDocGrammar=findGrammar(newDoc);
          if(newDocGrammar==null) {
            newDocGrammar=TMPresentationReconciler.this.grammar;
          }else {
            TMPresentationReconciler.this.grammar=newDocGrammar;
          }
        }
        if(newDocGrammar==null) {
          TMPresentationReconciler.this.colorizer=null;
          TMPresentationReconciler.this.grammar=null;
          if(PreferenceUtils.isDebugThrowError()) throw new TMException("Cannot find TextMate grammar for the given document!");
          return;
        }
        // update the theme
        final String scopeName=newDocGrammar.getScopeName();
        var theme=TMPresentationReconciler.this.theme;
        if(theme==null) {
          RGB rgb=viewer.getTextWidget().getBackground().getRGB();
          theme=TMPresentationReconciler.this.theme=TMUIPlugin.getThemeManager().getThemeForScope(scopeName,
            new Color(rgb.red,rgb.green,rgb.blue,1));
        }
        TMPresentationReconciler.this.colorizer=new Colorizer(viewer,theme,listeners);
        // connect a TextMate model to the new document
        final var docModel=TMModelManager.INSTANCE.connect(newDoc);
        docModel.setGrammar(newDocGrammar);
        docModel.addModelTokensChangedListener(modelsTokensChangedListener);
      }catch(final CoreException ex) {
        Platform.getLog(Platform.getBundle(TMEclipseRegistryPlugin.PLUGIN_ID))
          .log(new Status(IStatus.ERROR,TMUIPlugin.PLUGIN_ID,"Error while initializing TextMate model.",ex));
      }
    }
    @Override
    public void textChanged(final @Nullable TextEvent event) {
      if(event==null||!event.getViewerRedrawState()) return;
      final var viewer=TMPresentationReconciler.this.viewer;
      if(viewer==null) return;
      // case 1) changed text: propagate previous style (which will be overridden later asynchronously by TMModel.TokenizerThread)
      if(event.getDocumentEvent()!=null) {
        final int diff=event.getText().length()-event.getLength();
        if(diff==0||event.getOffset()<=0) return;
        final StyleRange range=viewer.getTextWidget().getStyleRangeAtOffset(event.getOffset()-1);
        if(range==null) return;
        range.length=Math.max(0,range.length+diff);
        viewer.getTextWidget().setStyleRange(range);
        return;
      }
      // case 2) TextViewer#invalidateTextPresentation is called (because of validation, folding, AnnotationPainter, etc.)
      final IDocument doc=viewer.getDocument();
      if(doc==null) return;
      final IRegion region=computeRegionToRedraw(event,doc);
      final var colorizer=TMPresentationReconciler.this.colorizer;
      if(colorizer!=null) {
        // case where there is grammar & theme -> update text presentation with the grammar tokens
        // It's possible that there are two or more SourceViewers opened for the same document,
        // so when one of them is closed the existing TMModel is also "closed" and its TokenizerThread
        // is interrupted and terminated.
        // In this case, in order to let the others Source Viewers to continue working a new
        // TMModel object is to be created for the document, so it should be initialized
        // with the existing grammar as well as new ModelTokensChangedListener is to be added.
        final var docModel=TMModelManager.INSTANCE.connect(doc);
        docModel.setGrammar(castNonNull(grammar));
        docModel.addModelTokensChangedListener(modelsTokensChangedListener);
        try {
          colorizer.colorize(region,docModel);
        }catch(final BadLocationException ex) {
          TMUIPlugin.logError(ex);
        }
      }else {
        // case where there is no grammar & theme -> update text presentation with the default styles
        // (i.e. to support highlighting with GenericEditor)
        final var presentation=new TextPresentation(region,100);
        presentation.setDefaultStyleRange(new StyleRange(region.getOffset(),region.getLength(),null,null));
        viewer.changeTextPresentation(presentation,false);
      }
    }
    IRegion computeRegionToRedraw(final TextEvent event,final IDocument doc) {
      final IRegion region=event.getOffset()==0&&event.getLength()==0&&event.getText()==null
        ?new Region(0,doc.getLength()) // redraw state change, damage the whole document
        :getRegionOfTextEvent(event);
      return region==null||region.getLength()==0
        ?new Region(0,0)
        :region;
    }
    @Nullable
    IRegion getRegionOfTextEvent(final TextEvent event) {
      final var text=event.getText();
      final int length=text==null?0:text.length();
      final var viewer=castNonNull(TMPresentationReconciler.this.viewer);
      return viewer instanceof final ITextViewerExtension5 viewerExt5
        ?viewerExt5.widgetRange2ModelRange(new Region(event.getOffset(),length))
        :new Region(event.getOffset()+viewer.getVisibleRegion().getOffset(),length);
    }
  }
  private @Nullable IGrammar findGrammar(final IDocument doc) throws CoreException {
    final IGrammar currentGrammar=isForcedGrammar?this.grammar:null;
    if(currentGrammar!=null) return currentGrammar;
    final ContentTypeInfo info=ContentTypeHelper.findContentTypes(doc);
    if(info==null) return null;
    final IContentType[] contentTypes=info.getContentTypes();
    // try to determine the grammar based on the content types
    IGrammar grammar=TMEclipseRegistryPlugin.getGrammarRegistryManager().getGrammarFor(contentTypes);
    if(grammar==null) {
      // try to determine the grammar based on the file type
      final String fileName=info.getFileName();
      if(fileName.indexOf('.')>-1) {
        final String fileType=new Path(fileName).getFileExtension();
        if(fileType!=null) {
          grammar=TMEclipseRegistryPlugin.getGrammarRegistryManager().getGrammarForFileType(fileType);
        }
      }
    }
    return grammar;
  }
  public @Nullable IGrammar getGrammar() {
    return grammar;
  }
  public void setGrammar(final @Nullable IGrammar newGrammar) {
    if(newGrammar==null&&this.grammar==null) return;
    this.isForcedGrammar=newGrammar!=null;
    if(Objects.equals(newGrammar,this.grammar)) return;
    if(newGrammar==null) colorizer=null;
    this.grammar=newGrammar;
    final IDocument doc=getViewerDocument();
    if(doc==null) return;
    // since Grammar has changed, recreate the TextMate model
    viewerListener.inputDocumentAboutToBeChanged(doc,null);
    viewerListener.inputDocumentChanged(null,doc);
  }
  public @Nullable ITokenProvider getTokenProvider() {
    return theme;
  }
  public void setTheme(final ITokenProvider newTheme) {
    if(!Objects.equals(this.theme,newTheme)) {
      this.theme=newTheme;
      final var viewer=this.viewer;
      if(grammar==null||viewer==null) return;
      final var colorizer=TMPresentationReconciler.this.colorizer=new Colorizer(viewer,newTheme,listeners);
      final IDocument doc=getViewerDocument();
      if(doc==null) return;
      final var docModel=TMModelManager.INSTANCE.connect(doc);
      try {
        colorizer.colorize(new Region(0,doc.getLength()),docModel);
      }catch(final BadLocationException ex) {
        TMUIPlugin.logError(ex);
      }
    }
  }
  @Override
  public void install(@NonNullByDefault({}) ITextViewer viewer) {
    this.viewer=viewer;
    viewer.addTextInputListener(viewerListener);
    final IDocument doc=viewer.getDocument();
    if(doc!=null) {
      viewerListener.inputDocumentChanged(null,doc);
    }
    ThemeManager.getInstance().addPreferenceChangeListener(themeChangeListener);
  }
  @Override
  public void uninstall() {
    final var viewer=castNonNull(this.viewer);
    viewer.removeTextInputListener(viewerListener);
    viewerListener.inputDocumentAboutToBeChanged(viewer.getDocument(),null);
    ThemeManager.getInstance().removePreferenceChangeListener(themeChangeListener);
    this.viewer=null;
  }
  @Override
  public @Nullable IPresentationDamager getDamager(final @Nullable String contentType) {
    return null;
  }
  @Override
  public @Nullable IPresentationRepairer getRepairer(final @Nullable String contentType) {
    return null;
  }
  private @Nullable IDocument getViewerDocument() {
    final var viewer=this.viewer;
    if(viewer==null) return null;
    return viewer.getDocument();
  }
  public boolean addListener(final ITMPresentationReconcilerListener listener) {
    return listeners.add(listener);
  }
  public boolean removeListener(final ITMPresentationReconcilerListener listener) {
    return listeners.remove(listener);
  }
  public boolean isEnabled() {
    return colorizer!=null;
  }
}
